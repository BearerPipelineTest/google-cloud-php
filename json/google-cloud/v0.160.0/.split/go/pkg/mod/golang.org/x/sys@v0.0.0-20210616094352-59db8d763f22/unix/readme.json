{"id":".split\/go\/pkg\/mod\/golang.org\/x\/sys@v0.0.0-20210616094352-59db8d763f22\/unix\/readme","type":"guide","title":"Building sys\/unix","name":"Building sys\/unix","description":"<body>\n<p>The sys\/unix package provides access to the raw system call interface of the\nunderlying operating system. See: <a href=\"https:\/\/godoc.org\/golang.org\/x\/sys\/unix\">https:\/\/godoc.org\/golang.org\/x\/sys\/unix<\/a><\/p>\n<p>Porting Go to a new architecture\/OS combination or adding syscalls, types, or\nconstants to an existing architecture\/OS pair requires some manual effort;\nhowever, there are tools that automate much of the process.<\/p>\n<h2>Build Systems<\/h2>\n<p>There are currently two ways we generate the necessary files. We are currently\nmigrating the build system to use containers so the builds are reproducible.\nThis is being done on an OS-by-OS basis. Please update this documentation as\ncomponents of the build system change.<\/p>\n<h3>Old Build System (currently for <code>GOOS != \"linux\"<\/code>)<\/h3>\n<p>The old build system generates the Go files based on the C header files\npresent on your system. This means that files\nfor a given GOOS\/GOARCH pair must be generated on a system with that OS and\narchitecture. This also means that the generated code can differ from system\nto system, based on differences in the header files.<\/p>\n<p>To avoid this, if you are using the old build system, only generate the Go\nfiles on an installation with unmodified header files. It is also important to\nkeep track of which version of the OS the files were generated from (ex.\nDarwin 14 vs Darwin 15). This makes it easier to track the progress of changes\nand have each OS upgrade correspond to a single change.<\/p>\n<p>To build the files for your current OS and architecture, make sure GOOS and\nGOARCH are set correctly and run <code>mkall.sh<\/code>. This will generate the files for\nyour specific system. Running <code>mkall.sh -n<\/code> shows the commands that will be run.<\/p>\n<p>Requirements: bash, go<\/p>\n<h3>New Build System (currently for <code>GOOS == \"linux\"<\/code>)<\/h3>\n<p>The new build system uses a Docker container to generate the go files directly\nfrom source checkouts of the kernel and various system libraries. This means\nthat on any platform that supports Docker, all the files using the new build\nsystem can be generated at once, and generated files will not change based on\nwhat the person running the scripts has installed on their computer.<\/p>\n<p>The OS specific files for the new build system are located in the <code>${GOOS}<\/code>\ndirectory, and the build is coordinated by the <code>${GOOS}\/mkall.go<\/code> program. When\nthe kernel or system library updates, modify the Dockerfile at\n<code>${GOOS}\/Dockerfile<\/code> to checkout the new release of the source.<\/p>\n<p>To build all the files under the new build system, you must be on an amd64\/Linux\nsystem and have your GOOS and GOARCH set accordingly. Running <code>mkall.sh<\/code> will\nthen generate all of the files for all of the GOOS\/GOARCH pairs in the new build\nsystem. Running <code>mkall.sh -n<\/code> shows the commands that will be run.<\/p>\n<p>Requirements: bash, go, docker<\/p>\n<h2>Component files<\/h2>\n<p>This section describes the various files used in the code generation process.\nIt also contains instructions on how to modify these files to add a new\narchitecture\/OS or to add additional syscalls, types, or constants. Note that\nif you are using the new build system, the scripts\/programs cannot be called normally.\nThey must be called from within the docker container.<\/p>\n<h3>asm files<\/h3>\n<p>The hand-written assembly file at <code>asm_${GOOS}_${GOARCH}.s<\/code> implements system\ncall dispatch. There are three entry points:<\/p>\n<pre><code>  func Syscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr)\n  func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)\n  func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr)<\/code><\/pre>\n<p>The first and second are the standard ones; they differ only in how many\narguments can be passed to the kernel. The third is for low-level use by the\nForkExec wrapper. Unlike the first two, it does not call into the scheduler to\nlet it know that a system call is running.<\/p>\n<p>When porting Go to a new architecture\/OS, this file must be implemented for\neach GOOS\/GOARCH pair.<\/p>\n<h3>mksysnum<\/h3>\n<p>Mksysnum is a Go program located at <code>${GOOS}\/mksysnum.go<\/code> (or <code>mksysnum_${GOOS}.go<\/code>\nfor the old system). This program takes in a list of header files containing the\nsyscall number declarations and parses them to produce the corresponding list of\nGo numeric constants. See <code>zsysnum_${GOOS}_${GOARCH}.go<\/code> for the generated\nconstants.<\/p>\n<p>Adding new syscall numbers is mostly done by running the build on a sufficiently\nnew installation of the target OS (or updating the source checkouts for the\nnew build system). However, depending on the OS, you may need to update the\nparsing in mksysnum.<\/p>\n<h3>mksyscall.go<\/h3>\n<p>The <code>syscall.go<\/code>, <code>syscall_${GOOS}.go<\/code>, <code>syscall_${GOOS}_${GOARCH}.go<\/code> are\nhand-written Go files which implement system calls (for unix, the specific OS,\nor the specific OS\/Architecture pair respectively) that need special handling\nand list <code>\/\/sys<\/code> comments giving prototypes for ones that can be generated.<\/p>\n<p>The mksyscall.go program takes the <code>\/\/sys<\/code> and <code>\/\/sysnb<\/code> comments and converts\nthem into syscalls. This requires the name of the prototype in the comment to\nmatch a syscall number in the <code>zsysnum_${GOOS}_${GOARCH}.go<\/code> file. The function\nprototype can be exported (capitalized) or not.<\/p>\n<p>Adding a new syscall often just requires adding a new <code>\/\/sys<\/code> function prototype\nwith the desired arguments and a capitalized name so it is exported. However, if\nyou want the interface to the syscall to be different, often one will make an\nunexported <code>\/\/sys<\/code> prototype, and then write a custom wrapper in\n<code>syscall_${GOOS}.go<\/code>.<\/p>\n<h3>types files<\/h3>\n<p>For each OS, there is a hand-written Go file at <code>${GOOS}\/types.go<\/code> (or\n<code>types_${GOOS}.go<\/code> on the old system). This file includes standard C headers and\ncreates Go type aliases to the corresponding C types. The file is then fed\nthrough godef to get the Go compatible definitions. Finally, the generated code\nis fed though mkpost.go to format the code correctly and remove any hidden or\nprivate identifiers. This cleaned-up code is written to\n<code>ztypes_${GOOS}_${GOARCH}.go<\/code>.<\/p>\n<p>The hardest part about preparing this file is figuring out which headers to\ninclude and which symbols need to be <code>#define<\/code>d to get the actual data\nstructures that pass through to the kernel system calls. Some C libraries\npreset alternate versions for binary compatibility and translate them on the\nway in and out of system calls, but there is almost always a <code>#define<\/code> that can\nget the real ones.\nSee <code>types_darwin.go<\/code> and <code>linux\/types.go<\/code> for examples.<\/p>\n<p>To add a new type, add in the necessary include statement at the top of the\nfile (if it is not already there) and add in a type alias line. Note that if\nyour type is significantly different on different architectures, you may need\nsome <code>#if\/#elif<\/code> macros in your include statements.<\/p>\n<h3>mkerrors.sh<\/h3>\n<p>This script is used to generate the system's various constants. This doesn't\njust include the error numbers and error strings, but also the signal numbers\nand a wide variety of miscellaneous constants. The constants come from the list\nof include files in the <code>includes_${uname}<\/code> variable. A regex then picks out\nthe desired <code>#define<\/code> statements, and generates the corresponding Go constants.\nThe error numbers and strings are generated from <code>#include &lt;errno.h&gt;<\/code>, and the\nsignal numbers and strings are generated from <code>#include &lt;signal.h&gt;<\/code>. All of\nthese constants are written to <code>zerrors_${GOOS}_${GOARCH}.go<\/code> via a C program,\n<code>_errors.c<\/code>, which prints out all the constants.<\/p>\n<p>To add a constant, add the header that includes it to the appropriate variable.\nThen, edit the regex (if necessary) to match the desired constant. Avoid making\nthe regex too broad to avoid matching unintended constants.<\/p>\n<h3>mkmerge.go<\/h3>\n<p>This program is used to extract duplicate const, func, and type declarations\nfrom the generated architecture-specific files listed below, and merge these\ninto a common file for each OS.<\/p>\n<p>The merge is performed in the following steps:<\/p>\n<ol>\n<li>Construct the set of common code that is idential in all architecture-specific files.<\/li>\n<li>Write this common code to the merged file.<\/li>\n<li>Remove the common code from all architecture-specific files.<\/li>\n<\/ol>\n<h2>Generated files<\/h2>\n<h3><code>zerrors_${GOOS}_${GOARCH}.go<\/code><\/h3>\n<p>A file containing all of the system's generated error numbers, error strings,\nsignal numbers, and constants. Generated by <code>mkerrors.sh<\/code> (see above).<\/p>\n<h3><code>zsyscall_${GOOS}_${GOARCH}.go<\/code><\/h3>\n<p>A file containing all the generated syscalls for a specific GOOS and GOARCH.\nGenerated by <code>mksyscall.go<\/code> (see above).<\/p>\n<h3><code>zsysnum_${GOOS}_${GOARCH}.go<\/code><\/h3>\n<p>A list of numeric constants for all the syscall number of the specific GOOS\nand GOARCH. Generated by mksysnum (see above).<\/p>\n<h3><code>ztypes_${GOOS}_${GOARCH}.go<\/code><\/h3>\n<p>A file containing Go types for passing into (or returning from) syscalls.\nGenerated by godefs and the types file (see above).<\/p><\/body>","methods":[]}